如果使用自定义值类型当作字典的key时，一定要继承Iequatable<T>接口，且重写Equals和GetHasCode方法，查看源码，可以看到Add中调用了Inset，Inset中有一句代码

```c#
int num1 = this.comparer.GetHashCode(key) & int.MaxValue;
```

这个comparer是在构造函数中获得的，

```c#
EqualityComparer<T>.CreateComparer();
```

直接说结论，添加会调用GetHashCode，删除会调用Equals，

如果不重写GetHashCode，会直接调用object.GetHashCode，这个方法会把实例装箱为Object，产生GC。

如果不继承IEquatable<T>，删除时调用Equals，会去调用object.Equals，调用时会装箱为Object，产生GC。

继承之后，调用Equals，因为泛型约束为接口类型，直接调用重写的方法。

